#!/usr/bin/env bash
set -o errexit
set -o pipefail

progname="$(basename "$0")"

main () {
    local source
    local target
    local star1=""
    local star2=""
    local -a cmd
    local ab
    local a
    local b
    
    if (( $# )) ; then
        source="$1"; shift
    else
        source="$(git rev-parse --abbrev-ref HEAD)"
    fi
    
    if (( $# )) ; then
        target="$1"; shift
    else
        target="$(git for-each-ref --format='%(upstream:short)' "refs/heads/${source}")"
    fi

    case "${GIT_FOR_EACH_BRANCH_STAR}" in
        1) star1="* "; star2="  ";;
        0) star1="  "; star2="  ";;
    esac

    cmd=(
        git rev-list
        --left-right
        "${source}..${target}"
        --count
    )

    ab="$("${cmd[@]}")"
    a="${ab%$'\t'*}"
    b="${ab#*$'\t'}"

    if (( ahead && behind )) ; then
        if (( zero || (a && b) )) ; then
            echo -n "${star1}"
            echo "${source} is ${a} commits ahead and ${b} commits behind ${target}"
        elif (( a )) ; then
            echo -n "${star1}"
            echo "${source} is ${a} commits ahead of ${target}"
        elif (( b )) ; then
            echo -n "${star1}"
            echo "${source} is ${b} commits behind ${target}"
        fi
    elif (( ahead && (a || zero) )) ; then
        echo -n "${star1}"
        echo "${source} is ${a} commits ahead of ${target}"
    elif (( behind && (b || zero) )) ; then
        echo -n "${star1}"
        echo "${source} is ${b} commits behind ${target}"
    fi
}

usage () { cat <<EOF; }
usage:
  ${progname} [<option> ...] [<source> [<target>]]
defaults:
  <source> defaults to the current branch
  <target> defaults to <source>'s remote
options:
  -a, --ahead    only show number of commits ahead
  -b, --behind   only show number of commits behind
  -z, --zero     show all ahead/behind counts including zeroes
  -h, --help     show this message
  -n, --dry-run  take no action (if applicable)
  -v, --verbose  additional output (if applicable)
EOF

ahead=""
behind=""
zero=0

dry_run=0
verbose=0

check_options () {
    local OPTION
    
    while getopts 'abzhnv-:' OPTION ; do
        if [[ "${OPTION}" = "-" ]] ; then
            if [[ "${OPTARG}" = "" ]] ; then # "--" by itself
                break
            fi
            OPTION="${OPTARG}"
            unset OPTARG
            if [[ "${OPTION}" = *"="* ]] ; then
                OPTARG="${OPTION#*=}"
                OPTION="${OPTION%%=*}"
            fi
        fi
        case "${OPTION}" in
            a|ahead)
                ahead="${OPTARG:-1}"
                : "${behind:=0}"
                ;;
            b|behind)
                behind="${OPTARG:-1}"
                : "${ahead:=0}"
                ;;
            z|zero)
                zero="${OPTARG:-1}"
                ;;

            h|help)
                usage; exit 0;;
            n|dry-run)
                dry_run="${OPTARG:-1}";;
            v|verbose)
                verbose="${OPTARG:-$((verbose + 1))}";;
            "?")
                exit 1;;
            ??*)                # length >= 2
                >&2 echo "${progname}: invalid option: --${OPTION}"; exit 1;;
            *)                  # length < 2
                >&2 echo "${progname}: invalid option: -${OPTION}"; exit 1;;
        esac
    done

    : "${behind:=1}"
    : "${ahead:=1}"
}

###############################################################################

check_options "$@"
shift $((OPTIND - 1))
main "$@"
