#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;
use utf8;

use open ':locale';

use Getopt::Long;

select(STDOUT); $| = 1;
select(STDERR); $| = 1;
select(STDOUT);

my $g2 = My::Git::Graph2->new();

our $ascii;
our $showParents;
our $stdin;
our $verbosity = 0;
our $dryRun;

Getopt::Long::Configure('bundling', 'gnu_compat', 'no_ignore_case');
Getopt::Long::GetOptions(
    'ascii'                => \$ascii,
    'parents|show-parents' => \$showParents,
    'stdin'                => \$stdin,

    # git log options
    'abbrev:i'             => sub { $g2->getoptLongOption('--abbrev', 'optional', @_); },
    'abbrev-commit'        => sub { $g2->getoptLongOption('--abbrev-commit'); },
    'no-abbrev-commit'     => sub { $g2->getoptLongOption('--no-abbrev-commit'); },
    'all'                  => sub { $g2->getoptLongOption('--all'); },
    'author-date-order'    => sub { $g2->getoptLongOption('--author-date-order'); },
    'date-order'           => sub { $g2->getoptLongOption('--date-order'); },
    'decorate:s'           => sub { $g2->getoptLongOption('--decorate', 'optional', @_); },
    'name-status'          => sub { $g2->getoptLongOption('--name-status'); },
    'oneline|one-line'     => sub { $g2->getoptLongOption('--oneline'); },
    'pretty:s'             => sub { $g2->getoptLongOption('--pretty', 'optional', @_); },
    'topo-order'           => sub { $g2->getoptLongOption('--topo-order'); },

    'v|verbose+'           => \$verbosity,
    'h|help'               => sub { usage(); exit(0); },
    'n|dry-run'            => \$dryRun,
) or die("Type '$0 --help' for help.\n");

$g2->verbosity($verbosity);
$g2->ascii($ascii);
$g2->showParents($showParents);
$g2->stdin($stdin);

if ($g2->verbosity || $g2->dryRun) {
    say(scalar($g2->getGitCommand(@ARGV)));
}

if ($g2->dryRun) {
    exit(0);
}

$g2->run(@ARGV);

sub usage { print(<<"END"); }
usage:
    git graph2 [<option> ...] [<revision range>] [[--] <path> ...]
    git graph2 --stdin [<option> ...] [<filename> ...]
options:
    --ascii
    --show-parents
    --abbrev
    --stdin              read from stdin (or files) instead of running git log
options passed to git log:
    --abbrev[=<n>]
    --abbrev-commit
    --all
    --author-date-order
    --date-order
    --decorate[=short|full|auto|no]
    --name-status
    --oneline
    --pretty[=<format>]
    --topo-order
END

package My::Git::Graph2 {
    use String::ShellQuote qw(shell_quote);
    use Text::Tabs qw(expand);
    use Data::Dumper qw(Dumper);
    use Storable qw(dclone);
    use Moo;

    use constant BLACK_CIRCLE_FOR_RECORD   => '⏺'; # U+23FA
    use constant BULLET                    => '•'; # U+2022
    use constant END_OF_PROOF              => '∎'; # U+220E
    use constant BLACK_SQUARE_FOR_STOP     => '⏹'; # U+23F9
    use constant BLACK_SQUARE              => '■'; # U+25A0
    use constant BLACK_DIAMOND             => '◆'; # U+25C6
    use constant BLACK_CIRCLE              => '●'; # U+25CF
    use constant BLACK_MEDIUM_SQUARE       => '◼'; # U+25FC
    use constant BLACK_MEDIUM_SMALL_SQUARE => '◾'; # U+25FE
    use constant MEDIUM_BLACK_CIRCLE       => '⚫'; # U+26AB
    use constant BLACK_LARGE_SQUARE        => '⬛'; # U+2B1B
    use constant BLACK_LARGE_CIRCLE        => '⬤'; # U+2B24

    use constant THIS_COMMIT               => BLACK_SQUARE;
    use constant THIS_COMMIT_ASCII         => '*';

    INIT {
        # state
        has commitLog              => (is => 'rw', default => sub { return []; });
        has commit                 => (is => 'rw');
        has parents                => (is => 'rw', default => sub { return []; });
        has columns                => (is => 'rw', default => sub { return []; });
        has commitColumnNumber     => (is => 'rw');
        has columnNumbers          => (is => 'rw', default => sub { return {}; });
        has hasKtulu               => (is => 'rw', default => 0);

        has gitLogOptions          => (is => 'rw', default => sub { return []; });

        # options
        has ascii                  => (is => 'rw', default => 0);
        has showParents            => (is => 'rw', default => 0);
        has padding                => (is => 'rw', default => 32);
        has stdin                  => (is => 'rw', default => 0);
        has breathingRoom          => (is => 'rw', default => 0);
        has verbosity              => (is => 'rw', default => 0);
        has dryRun                 => (is => 'rw', default => 0);

        has style                  => (is => 'rw', default => 1);
    }

    sub run {
        my ($self, @args) = @_;
        if ($self->stdin) {
            $self->runStdin(@args);
        } else {
            $self->runGit(@args);
        }
    }

    sub getoptLongOption {
        my ($self, $option, $type, @getoptLongArgs) = @_;
        my ($optionName, $value, $key) = @getoptLongArgs;

        $type //= 'none';

        if (defined $value) {
            if ($type eq 'required') {
                push(@{$self->gitLogOptions}, $option . '=' . $value);
            } else {
                if ($value eq '') {
                    push(@{$self->gitLogOptions}, $option);
                } else {
                    push(@{$self->gitLogOptions}, $option . '=' . $value);
                }
            }
        } else {
            if ($type eq 'required') {
                push(@{$self->gitLogOptions}, $option . '=');
            } else {
                push(@{$self->gitLogOptions}, $option);
            }
        }
    }

    sub runStdin {
        my ($self, @args) = @_;
        $self->initialize();
        $self->runFileHandle(\*ARGV);
    }

    sub runGit {
        my ($self, @args) = @_;
        $self->initialize();
        my $ph;
        if (!open($ph, '-|', 'git', 'log', '--parents',
                  @{$self->gitLogOptions},
                  @args)) {
            warn("failed to open pipe to git: $!\n");
            return;
        }
        $self->runFileHandle($ph);
    }

    sub runFileHandle {
        my ($self, $fh) = @_;
        local $_ = undef; # $ARG (the default input and pattern-matching space)
        local $/ = "\n";  # $INPUT_RECORD_SEPARATOR
        my @commit;
        while (<$fh>) {
            my $origLine = $_;
            s{\R\z}{};
            $_ = expand($_);    # tabs lol
            my $line = $_;
            $self->parseLine($line);
        }
        $self->eof();
    }

    sub initialize {
        my ($self) = @_;
    }

    sub parseLine {
        my ($self, $line) = @_;
        my $origLine = $line;

        my $commit;

        if ($line =~ s{^\s*([[:xdigit:]]{8,})\s*}{}) {
            $commit = $1;
        } elsif ($line =~ s{^\s*commit\s+([[:xdigit:]]{8,})\s*}{}) {
            $commit = $1;
        } else {
            push(@{$self->commitLog}, $origLine);
            return;
        }

        my $newLine = '';
        $newLine .= $commit . ' ';
        my @parents;
        while ($line =~ s{^\s*([[:xdigit:]]{8,})\s*}{}) {
            my $parent = $1;
            if ($self->showParents) {
                $newLine .= $parent . ' ';
            }
            push(@parents, $parent);
        }
        $self->startNextCommit($newLine . $line, $commit, @parents);
    }

    sub eof {
        my ($self) = @_;
        if (defined $self->commit) {
            $self->printCommit();
        }
    }

    sub startNextCommit {
        my ($self, $line, $commit, @parents) = @_;

        if (defined $self->commit) {
            $self->printCommit();
        }

        $self->commitLog([$line]);
        $self->commit($commit);
        $self->parents(\@parents);
        $self->hasKtulu(0);
    }

    sub computeColumns {
        my ($self) = @_;

        my $commit = $self->commit; # always defined
        my $parent = $self->parents->[0];

        my $commitColumnNumber = $self->columnNumbers->{$commit};
        my $parentColumnNumber = defined $parent ? $self->columnNumbers->{$parent} : undef;
        my $commitColumn       = defined $commitColumnNumber ? $self->columns->[$commitColumnNumber] : undef;
        my $parentColumn       = defined $parentColumnNumber ? $self->columns->[$parentColumnNumber] : undef;

        if (!defined $commitColumnNumber && !defined $parentColumnNumber) {
            $commitColumnNumber = scalar @{$self->columns};
            $parentColumnNumber = scalar @{$self->columns} if defined $parent;
            $self->columnNumbers->{$commit} = $commitColumnNumber;
            $self->columnNumbers->{$parent} = $parentColumnNumber if defined $parentColumnNumber;
            $commitColumn = {
                number => $commitColumnNumber,
                commit => $parent,
                parentNumber => $parentColumnNumber,
            };
            $parentColumn = $commitColumn if defined $parent;
            push(@{$self->columns}, $commitColumn);
        } elsif (!defined $parentColumnNumber) {
            $commitColumn->{commit} = $parent;
            if (defined $parent) {
                $parentColumnNumber = $commitColumnNumber;
                $self->columnNumbers->{$parent} = $parentColumnNumber;
                $parentColumn = $commitColumn;
                $commitColumn->{commit} = $parent;
                $commitColumn->{parentNumber} = $parentColumnNumber;
            }
        } elsif (!defined $commitColumnNumber) {
            $commitColumnNumber = scalar @{$self->columns};
            $self->columnNumbers->{$commit} = $commitColumnNumber;
            $commitColumn = {
                number => $commitColumnNumber,
                commit => $parent,
                parentNumber => $parentColumnNumber,
            };
            push(@{$self->columns}, $commitColumn);
        } else {
            $commitColumn->{parent} = $parent;
            $commitColumn->{parentNumber} = $parentColumnNumber;
            if ($commitColumn->{number} != $commitColumn->{parentNumber}) {
                $self->hasKtulu(1);
            }
        }

        foreach my $otherParent (@{$self->parents}) {
            my $columnNumber = $self->columnNumbers->{$otherParent};
            if (!defined $columnNumber) {
                $columnNumber = scalar @{$self->columns};
                $self->columnNumbers->{$otherParent} = $columnNumber;
                my $column = {
                    number => $columnNumber,
                    commit => $parent,
                    parentNumber => $columnNumber,
                    new => 1,
                };
                push(@{$self->columns}, $column);
                $self->hasKtulu(1);
            }
        }

        $self->commitColumnNumber($commitColumnNumber);
    }

    sub computeGraphLine {
        my ($self) = @_;
        my $result = '';
        for (my $i = 0; $i < scalar @{$self->columns}; $i += 1) {
            my $column = $self->columns->[$i];
            if (!defined $column || $column->{closing}) {
                $result .= '  ';
            } elsif ($i == $self->commitColumnNumber) {
                $result .= THIS_COMMIT       if !$self->ascii;
                $result .= THIS_COMMIT_ASCII if $self->ascii;
                $result .= ' ';
            } elsif (defined $column->{commit} && !$column->{new}) {
                $result .= '| ' if $self->ascii;
                $result .= '│ ' if !$self->ascii;
            } else {
                $result .= '  ';
            }
        }
        $result = sprintf('%-*s', $self->padding, $result);
        return $result;
    }

    sub computePostGraphLine {
        my ($self) = @_;
        my $result = '';
        for (my $i = 0; $i < scalar @{$self->columns}; $i += 1) {
            my $column = $self->columns->[$i];
            if (!defined $column || $column->{closing}) {
                $result .= '  ';
            } elsif (defined $column->{commit} && !$column->{new}) {
                $result .= '| ' if $self->ascii;
                $result .= '│ ' if !$self->ascii;
            } else {
                $result .= '  ';
            }
        }
        $result = sprintf('%-*s', $self->padding, $result);
        return $result;
    }

    use List::Util qw(min max);

    sub computeKtuluLine {
        my ($self) = @_;
        my $result = "";
        my @p = grep { defined $_ } map { $self->columnNumbers->{$_} } @{$self->parents};
        my $minp = min(@p);
        my $maxp = max(@p);
        my %p = map { ($_ => 1) } @p;
        for (my $i = 0; $i < scalar @{$self->columns}; $i += 1) {
            my $column = $self->columns->[$i];
            if ($i < $self->commitColumnNumber) {
                my $hbar = defined $minp && $i >= $minp;
                if (!defined $column || $column->{closing}) {
                    $result .= $hbar ? ($self->ascii ? '--' : '──') : '  ';
                } elsif ($p{$i}) {
                    $result .= ($self->ascii ? ".-" : "╭─");
                } elsif (defined $column->{commit}) {
                    $result .= $hbar ? '|-' : '| ' if $self->ascii;
                    $result .= $hbar ? '┼─' : '│ ' if !$self->ascii;
                } else {
                    $result .= "  ";
                }
            } elsif ($i == $self->commitColumnNumber) {
                if (defined $column->{parentNumber} && $i != $column->{parentNumber}) {
                    if ($i < $column->{parentNumber}) {
                        $result .= $self->ascii ? "'" : "╰";
                    } else {
                        $result .= $self->ascii ? "'" : "╯";
                    }
                } elsif (scalar(@p) && ($minp < $i || $i < $maxp)) {
                    my $left = $minp < $i;
                    my $right = $maxp > $i;
                    $result .= "'" if $self->ascii;
                    $result .= "╯" if !$self->ascii && $left && !$right;
                    $result .= "╰" if !$self->ascii && !$left && $right;
                    $result .= "┴" if !$self->ascii && $left && $right;
                } else {
                    $result .= ($self->ascii ? "|" : "│");
                }
            } else {
                my $hbar = defined $maxp && $i <= $maxp;
                if (!defined $column || $column->{closing}) {
                    $result .= $hbar ? ($self->ascii ? '--' : '──') : '  ';
                } elsif ($p{$i}) {
                    $result .= ($self->ascii ? "-." : "─╮");
                } elsif (defined $column->{commit}) {
                    $result .= $hbar ? '-|' : ' |' if $self->ascii;
                    $result .= $hbar ? '─┼' : ' │' if !$self->ascii;
                } else {
                    $result .= "  ";
                }
            }
        }
        $result .= " ";
        $result = sprintf('%-*s', $self->padding, $result);
        return $result;
    }

    sub cleanupColumns {
        my ($self) = @_;
        for (my $i = 0; $i < scalar @{$self->columns}; $i += 1) {
            my $column = $self->columns->[$i];
            if (defined $column) {
                if ($column->{closing}) {
                    $self->columns->[$i] = undef;
                }
            }
        }
        for (my $i = 0; $i < scalar @{$self->columns}; $i += 1) {
            my $column = $self->columns->[$i];
            if (defined $column) {
                my $number = $column->{number};
                my $parentNumber = $column->{parentNumber};
                if (!defined $parentNumber || $number != $parentNumber) {
                    if ($self->breathingRoom) {
                        $self->columns->[$i]->{closing} = 1;
                    } else {
                        $self->columns->[$i] = undef;
                    }
                }
            }
        }
        for (my $i = 0; $i < scalar @{$self->columns}; $i += 1) {
            my $column = $self->columns->[$i];
            if (defined $column) {
                $column->{new} = 0;
            }
        }
        while (scalar @{$self->columns} && !defined $self->columns->[-1]) {
            pop(@{$self->columns});
        }
    }

    sub computeGraphLine2 {
        my ($self) = @_;
        my $result = "";
        my @p = grep { defined $_ } map { $self->columnNumbers->{$_} } @{$self->parents};
        my $minp = min(@p);
        my $maxp = max(@p);
        my %p = map { ($_ => 1) } @p;
        for (my $i = 0; $i < scalar @{$self->columns}; $i += 1) {
            my $column = $self->columns->[$i];
            if ($i < $self->commitColumnNumber) {
                my $hbar = defined $minp && $i >= $minp;
                if (!defined $column || $column->{closing}) {
                    $result .= $hbar ? ($self->ascii ? '--' : '──') : '  ';
                } elsif ($p{$i}) {
                    $result .= ($self->ascii ? ".-" : "╭─");
                } elsif (defined $column->{commit}) {
                    $result .= $hbar ? '|-' : '| ' if $self->ascii;
                    $result .= $hbar ? '┼─' : '│ ' if !$self->ascii;
                } else {
                    $result .= "  ";
                }
            } elsif ($i == $self->commitColumnNumber) {
                $result .= THIS_COMMIT       if !$self->ascii;
                $result .= THIS_COMMIT_ASCII if $self->ascii;
            } else {
                my $hbar = defined $maxp && $i <= $maxp;
                if (!defined $column || $column->{closing}) {
                    $result .= $hbar ? ($self->ascii ? '--' : '──') : '  ';
                } elsif ($p{$i}) {
                    $result .= ($self->ascii ? "-." : "─╮");
                } elsif (defined $column->{commit}) {
                    $result .= $hbar ? '-|' : ' |' if $self->ascii;
                    $result .= $hbar ? '─┼' : ' │' if !$self->ascii;
                } else {
                    $result .= "  ";
                }
            }
        }
        $result .= " ";
        $result = sprintf('%-*s', $self->padding, $result);
        return $result;
    }

    sub printCommit {
        my ($self) = @_;

        $self->computeColumns();

        if ($self->style == 1) {
            my $graph = $self->computeGraphLine();
            my $post  = $self->computePostGraphLine();
            my $ktulu = $self->computeKtuluLine();

            my $first = 1;
            foreach my $log (@{$self->commitLog}) {
                if ($first) {
                    print($graph . $log . "\n");
                    $first = 0;
                } else {
                    print($post . $log . "\n");
                }
            }

            if ($self->hasKtulu) {
                print($ktulu . "\n");
            }
        } else {
            my $graph = $self->computeGraphLine2();
            my $post  = $self->computePostGraphLine();

            my $first = 1;
            foreach my $log (@{$self->commitLog}) {
                if ($first) {
                    print($graph . $log . "\n");
                    $first = 0;
                } else {
                    print($post . $log . "\n");
                }
            }
        }

        $self->cleanupColumns();
    }

    sub getGitCommand {
        my ($self, @args) = @_;
        my @cmd = (
            'git', 'log', '--parents',
            @{$self->gitLogOptions},
            @args
        );
        if (wantarray) {
            return @cmd;
        }
        return shell_quote(@cmd);
    }

};
