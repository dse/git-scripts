#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;

# This is a Git porcelain script that either runs the specified
# command with the specified arguments in the current directory if
# it's in a working tree, or finds git repositories within the current
# directory and runs the command/arguments in each of those if it's
# not.

use File::Basename qw(basename);

our $progname = basename($0);

our $maxdepth;
our $no_git;
our $basename;
our $inline;
our $no_brackets;
our $indent;
our $no_pty;
our $format;
our $format_width;
our $separator;
our $verbose;
our $dry_run;
our $errors_only;

use Getopt::Long;
Getopt::Long::Configure("bundling", "gnu_compat", "require_order");
Getopt::Long::GetOptions(
    "max-depth|maxdepth=i" => \$maxdepth,
    "no-git"               => \$no_git,
    "basename"             => \$basename,
    "inline"               => \$inline,
    "no-brackets"          => \$no_brackets,
    "indent"               => \$indent,
    "no-pty"               => \$no_pty,
    "format=s"             => \$format,
    "format-width=i"       => \$format_width,
    "separator=s"          => \$separator,
    "v|verbose+"           => \$verbose,
    "n|dry-run"            => \$dry_run,
    "errors-only"          => \$errors_only,
    "h|help" => sub {
        usage(); exit(0);
    }
) or die("Do not type '$0 --help' for help yet.\n");

###############################################################################
sub usage { print <<"END"; }
usage:
  ${progname} [<option> ...] <cmd> [<arg> ...] [--- <dir> ...]
options:
  --help                 display this message
  --max-depth=DEPTH      maximum nesting level to find subdirectories
  --no-git               run <cmd> [<arg> ...] instead of git <cmd> [<arg> ...]
  --basename             only show basenames, not full directory pathnames
  --inline               prepend directory names to command stdout/stderr
  --no-brackets          no brackets around directory names
  --indent               indent command stdout/stderr
  --format=FORMAT        e.g., --format='project %s:'
  --format-width=COLS    try to align output/errors
  --separator=SEPARATOR  between directory name and command stdout/stderr
                         can specify escapes, e.g., --separator='\\t'
  --verbose
  --dry-run
  --errors-only          only show output/stderr when commands fail
debugging:
  --no-pty               don't use pseudoterminals
END
###############################################################################

$ENV{GIT_PAGER} = "cat";
my $recurse = My::Git::Porcelain::All->new();
$recurse->{maxdepth}     = $maxdepth     if defined $maxdepth;
$recurse->{no_git}       = $no_git       if defined $no_git;
$recurse->{basename}     = $basename     if defined $basename;
$recurse->{inline}       = $inline       if defined $inline;
$recurse->{no_brackets}  = $no_brackets  if defined $no_brackets;
$recurse->{indent}       = $indent       if defined $indent;
$recurse->{no_pty}       = $no_pty       if defined $no_pty;
$recurse->{format}       = $format       if defined $format;
$recurse->{format_width} = $format_width if defined $format_width;
$recurse->{separator}    = $separator    if defined $separator;
$recurse->{verbose}      = $verbose      if defined $verbose;
$recurse->{dry_run}      = $dry_run      if defined $dry_run;
$recurse->{errors_only}  = $errors_only  if defined $errors_only;
$recurse->run(@ARGV);

package My::Git::Porcelain::All {

    use String::Unescape;

    sub new {
        my ($class) = @_;
        my $self = bless({}, $class);
        return $self;
    }

    # use My::Git::Porcelain::All::Util qw(spork);
    sub spork(&);
    INIT {
        import My::Git::Porcelain::All::Util qw(spork);
    }

    sub run {
        my ($self, @arguments) = @_;

        my ($command, $arguments, $directories) = $self->split_arguments(arguments => \@arguments);
        my @directories = @$directories;
        @arguments = @$arguments;

        if (!defined $command) {
            die("No command specified.  Type '$0 --help' for help.\n");
        }
        if ($command eq "test-git-all-porcelain") {
            printf("\$command:     %s\n", $command);
            printf("\@arguments:   %s (%s)\n", scalar @arguments, join " ", @arguments);
            printf("\@directories: %s (%s)\n", scalar @directories, join " ", @directories);
            exit(0);
        }
        if (scalar @directories) {
            foreach my $directory (@directories) {
                if (-d $directory) {
                    if ($self->is_in_git_repos(directory => $directory)) {
                        $self->run_git_command_in(directory => $directory,
                                                  relative_directory => $directory,
                                                  command => $command,
                                                  arguments => \@arguments);
                    } else {
                        $self->recurse_here(directory => $directory,
                                            command => $command,
                                            arguments => \@arguments);
                    }
                } else {
                    warn("$directory: not a directory\n");
                }
            }
        } else {
            if ($self->is_in_git_repos()) {
                $self->run_git_command_in(directory => ".",
                                          command => $command,
                                          arguments => \@arguments);
            } else {
                $self->recurse_here(command => $command,
                                    arguments => \@arguments);
            }
        }
    }

    sub split_arguments {
        my ($self, %args) = @_;
        my @arguments = @{$args{arguments}};

        my $three_dashes_index = undef;
      argument:
        for (my $i = 0; $i < @arguments; $i += 1) {
            if ($arguments[$i] eq "---") {
                $three_dashes_index = $i;
                last argument;
            }
        }

        my @directories;
        if (defined $three_dashes_index) {
            @directories = splice(@arguments, $three_dashes_index + 1);
            splice(@arguments, $three_dashes_index);
        }

        my $command = shift(@arguments);

        if (wantarray) {
            return ($command, \@arguments, \@directories);
        } else {
            return {
                command => $command,
                arguments => \@arguments,
                directories => \@directories
            };
        }
    }

    sub is_in_git_repos {
        my ($self, %args) = @_;
        my $dir = $args{directory};
        my $pid = spork {
            close(\*STDOUT);
            close(\*STDERR);
            if (defined $dir && $dir ne ".") {
                if (!chdir($dir)) {
                    die("chdir $dir: $!");
                }
            }
            if (!exec("git", "rev-parse", "--git-dir")) {
                die("exec git: $!");
            }
        };
        if (waitpid($pid, 0) == -1) {
            warn("unexpected: no child process\n");
            return 0;           # failure
        } else {
            if ($?) {
                return 0;       # failure
            } else {
                return 1;       # success
            }
        }
    }

    use File::Find;
    use feature "say";
    use Cwd;
    use File::Spec;
    use File::Basename qw(dirname basename);
    use String::ShellQuote;

    sub has_io_pty {
        my ($self) = @_;
        return 0 if $self->{no_pty};
        return $self->{has_io_pty} if defined $self->{has_io_pty};
        eval {
            require IO::Pty;
            import IO::Pty qw();
        };
        return $self->{has_io_pty} = $@ ? 0 : 1;
    }

    sub recurse_here {
        my ($self, %args) = @_;
        my $depth = $args{depth} // 0;
        my $dir = $args{directory} // ".";
        my $command = $args{command};
        my @arguments = @{$args{arguments}};

        if (defined $self->{maxdepth}) {
            if ($depth > $self->{maxdepth}) {
                return;
            }
        }

        my $wanted = sub {
            if (-d $_) {
                if (-d "$_/.git") {
                    my @splitdir = File::Spec->splitdir($File::Find::name);
                    my $splitdir = scalar @splitdir;
                    my $newdepth = $depth + $splitdir - 1;
                    if (defined $self->{maxdepth}) {
                        if ($newdepth > $self->{maxdepth}) {
                            $File::Find::prune = 1;
                            return;
                        }
                    }
                    $self->run_git_command_in(depth => $newdepth,
                                              directory => $File::Find::name,
                                              relative_directory => $_,
                                              command => $command,
                                              arguments => \@arguments);
                    $File::Find::prune = 1;
                }
            }
        };
        find({ wanted => $wanted }, $dir);
    }

    sub stdout {
        my ($self, $line) = @_;
        local $_ = $line;
        s{\R\z}{};
        if ($self->{inline}) {
            print STDOUT $self->{inline_prefix};
            print STDOUT $self->{inline_separator} if defined $self->{inline_separator};
        } elsif ($self->{indent}) {
            print STDOUT "    ";
        }
        print STDOUT "$_\n";
        STDOUT->flush();
    }

    sub stderr {
        my ($self, $line) = @_;
        local $_ = $line;
        s{\R\z}{};
        if ($self->{inline}) {
            print STDERR $self->{inline_prefix};
            print STDERR $self->{inline_separator} if defined $self->{inline_separator};
        } elsif ($self->{indent}) {
            print STDERR "    ";
        }
        print STDERR "$_\n";
        STDERR->flush();
    }

    sub run_git_command_in {
        my ($self, %args) = @_;
        my $depth = $args{depth} // 1;
        my $dir = $args{directory} // ".";
        $dir =~ s{^\.\/(?=.)}{};
        my $reldir = $args{relative_directory};
        my $command = $args{command};
        my @arguments = @{$args{arguments}};
        if ($command eq "list-git-directories") {
            print("$dir\n");
            return;
        }

        my $format = $self->{format};
        if (!defined $format) {
            $format = $self->{no_brackets} ? "%s" : "[%s]";
            if ($self->{inline}) {
                $format .= $self->{no_brackets} ? ":" : " ";
            }
        }
        my $dir_header = $self->{basename} ? basename($dir) : $dir;
        if (!$self->{inline} && !$self->{errors_only}) {
            printf($format . "\n", $dir_header);
        }
        my $inline_prefix = $self->{inline} && sprintf($format, $dir_header);
        if (defined $self->{format_width}) {
            $inline_prefix = sprintf("%-*s", $self->{format_width}, $inline_prefix);
        }
        my $inline_separator = defined $self->{separator} ? String::Unescape->unescape($self->{separator}) : undef;
        my $use_pipes_and_such = $self->{indent} || $self->{inline} || $self->{errors_only};

        $self->{inline_separator} = $inline_separator;
        $self->{inline_prefix} = $inline_prefix;

        # git <command> <args> writes to $*_write
        # our first child process reads from $stdout_read
        # our second child process reads from $stderr_read
        my ($stdout_read, $stdout_write);
        my ($stderr_read, $stderr_write);
        if ($use_pipes_and_such) {
            if ($self->has_io_pty) {
                $stdout_read = IO::Pty->new(); # master
                $stderr_read = IO::Pty->new(); # master
                $stdout_write = $stdout_read->slave();
                $stderr_write = $stderr_read->slave();
            } else {
                pipe($stdout_read, $stdout_write) or die("pipe: $!");
                pipe($stderr_read, $stderr_write) or die("pipe: $!");
            }
        }

        my @cmd = ($command, @arguments);
        if (!$self->{no_git}) {
            unshift(@cmd, "git");
        }

        if ($self->{verbose} || $self->{dry_run}) {
            warn(sprintf("+ %s\n", shell_quote(@cmd)));
        }

        if ($self->{dry_run}) {
            return;
        }

        my %proc;

        my $pid = spork {
            if (defined $reldir && $reldir ne ".") {
                if (!chdir($reldir)) {
                    die("chdir $reldir: $!");
                }
            }
            if ($use_pipes_and_such) {
                open(STDOUT, ">&", $stdout_write) or die("open: $!");
                open(STDERR, ">&", $stderr_write) or die("open: $!");
            }
            if (!exec(@cmd)) {
                die("exec $cmd[0]: $!");
            }
        };
        if ($cmd[0] eq "git") {
            $proc{$pid} = "git $cmd[1]";
        } else {
            $proc{$pid} = $cmd[0];
        }

        my ($pid1, $pid2);

        my $wait_report = sub {
            my ($pid, $status) = @_;
            $status //= $?;
            if ($pid == -1) {
                warn("unexpected: no child process\n");
            } elsif (!defined $pid) {
                warn("unexpected: wait returned undefined\n");
            } else {
                my $proc = $proc{$pid};
                if ($status && $self->{verbose}) {
                    $self->warn_child_error($status, $proc);
                }
            }
            $? = $status;
        };

        if ($self->{errors_only}) {
            close($stdout_write) or die("close: $!");
            close($stderr_write) or die("close: $!");

            STDOUT->autoflush(1);
            if (-t 1) {
                # show each project while git <cmd> is doing its work
                # on it.
                printf($format, $dir_header);
            }

            my $clear_to_eol = (-t 1) && `tput ce`;

            my $rin = '';
            vec($rin, fileno($stdout_read), 1) = 1;
            vec($rin, fileno($stderr_read), 1) = 1;

            my @lines;

            while (1) {
                my $rout = $rin;
                my $nfound = select(
                    $rout,
                    undef,
                    undef,
                    undef
                );
                if ($nfound == -1) {
                    warn("select: $!\n");
                    last;
                }
                if (!$nfound) {
                    last;
                }
                if (vec($rout, fileno($stdout_read), 1)) {
                    my $line = <$stdout_read>;
                    if (defined $line) {
                        push(@lines, { fh => "stdout", line => $line });
                    } else {
                        if ($!) {
                            warn("read: $!\n");
                        }
                        last;
                    }
                }
                if (vec($rout, fileno($stderr_read), 1)) {
                    my $line = <$stderr_read>;
                    if (defined $line) {
                        push(@lines, { fh => "stderr", line => $line });
                    } else {
                        if ($!) {
                            warn("read: $!\n");
                        }
                        last;
                    }
                }
            }
            {
                my $pid = wait();
                my $status = $?;
                if (-t 1) {
                    if ($status) {
                        # keep project name visible on terminal
                        print "\n";
                    } else {
                        # erase project name, no newline
                        print "\r${clear_to_eol}";
                    }
                } else {
                    if ($status) {
                        printf($format . "\n", $dir_header);
                    }
                }
                if (!$status) {
                    $wait_report->($pid, $status);
                }
                if ($status) {
                    foreach my $line (@lines) {
                        $self->stdout($line->{line}) if $line->{fh} eq "stdout";
                        $self->stderr($line->{line}) if $line->{fh} eq "stderr";
                    }
                }
            }
        } elsif ($use_pipes_and_such) {
            close($stdout_write) or die("close: $!");
            close($stderr_write) or die("close: $!");

            my $pid1 = spork {
                close($stderr_read) or die("close: $!");
                select STDOUT; $| = 1;
                local $_;
                while (<$stdout_read>) {
                    $self->stdout($_);
                }
                close($stdout_read) or die("close: $!");
            };
            $proc{$pid1} = "stdout pipe";

            my $pid2 = spork {
                close($stdout_read) or die("close: $!");
                select STDERR; $| = 1;
                local $_;
                while (<$stderr_read>) {
                    $self->stderr($_);
                }
                close($stderr_read) or die("close: $!");
            };
            $proc{$pid2} = "stderr pipe";

            close($stdout_read) or die("close: $!");
            close($stderr_read) or die("close: $!");

            {
                my $pid = wait();
                $wait_report->($pid);
            }
            {
                my $pid = wait();
                $wait_report->($pid);
            }
            {
                my $pid = wait();
                $wait_report->($pid);
            }
        }
    }

    sub child_error_info {
        my ($self, $status) = @_;
        $status //= $?;

        my $exit     = $status >> 8;
        my $signal   = $status & 127;
        my $coredump = ($status & 128) ? 1 : 0;
        if (wantarray) {
            return ($exit, $signal, $coredump);
        } else {
            return {
                exit     => $exit,
                signal   => $signal,
                coredump => $coredump
            };
        }
    }

    sub warn_child_error {
        my ($self, $status, @child) = @_;
        $status //= $?;

        my ($exit, $signal, $coredump) = $self->child_error_info($status);
        if ($exit || $signal || $coredump) {
            my @message;
            push(@message, "returned $exit")      if $exit;
            push(@message, "with signal $signal") if $signal;
            push(@message, "core dumped")         if $coredump;
            my $message = join(", ", @message);
            if (!scalar @child) {
                @child = ("child");
            }
            warn("@child died: $message\n");
        }
    }

};                              # end package My::Git::Porcelain::All

package My::Git::Porcelain::All::Util {
    use base "Exporter";

    our @EXPORT_OK;
    BEGIN {
        push(@EXPORT_OK, 'spork');
    }

    sub spork(&) {
        my ($sub) = @_;
        my $pid = fork;
        if (!defined $pid) {
            die("fork: $!\n");
        }
        if (!$pid) {
            $sub->();
            exit;
        }
        return $pid;
    }
};
