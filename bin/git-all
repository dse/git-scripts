#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;

# This is a Git porcelain script that either runs the specified
# command with the specified arguments in the current directory if
# it's in a working tree, or finds git repositories within the current
# directory and runs the command/arguments in each of those if it's
# not.

use lib "$ENV{HOME}/git/dse.d/git-scripts/share/git-scripts/perl";
use My::Git::All;

use File::Basename qw(basename);
use Getopt::Long;

our $progname = basename($0);

our $maxdepth;
our $no_git;
our $basename;
our $inline;
our $no_brackets;
our $indent;
our $no_pty;
our $format;
our $format_width;
our $separator;
our $verbose;
our $dry_run;
our $errors_only;
our $no_progress;

Getopt::Long::Configure("bundling", "gnu_compat", "require_order");
Getopt::Long::GetOptions(
    "max-depth|maxdepth=i" => \$maxdepth,
    "no-git"               => \$no_git,
    "basename"             => \$basename,
    "inline"               => \$inline,
    "no-brackets"          => \$no_brackets,
    "indent"               => \$indent,
    "no-pty"               => \$no_pty,
    "format=s"             => \$format,
    "format-width=i"       => \$format_width,
    "separator=s"          => \$separator,
    "v|verbose+"           => \$verbose,
    "n|dry-run"            => \$dry_run,
    "errors-only"          => \$errors_only,
    "no-progress"          => \$no_progress,
    "h|help" => sub {
        usage(); exit(0);
    }
) or die("Type '$0 --help' for help.\n");

###############################################################################
sub usage { print <<"END"; }
usage:
  ${progname} [<option> ...] <cmd> [<arg> ...] [--- <dir> ...]
options:
  --help                 display this message
  --max-depth=DEPTH      maximum nesting level to find subdirectories
  --no-git               run <cmd> [<arg> ...] instead of git <cmd> [<arg> ...]
  --basename             only show basenames, not full directory pathnames
  --inline               prepend directory names to command stdout/stderr
  --no-brackets          no brackets around directory names
  --indent               indent command stdout/stderr
  --format=FORMAT        e.g., --format='project %s:'
  --format-width=COLS    try to align output/errors
  --separator=SEPARATOR  between project name and command stdout/stderr
                         can specify escapes, e.g., --separator='\\t'
  --verbose
  --dry-run
  --errors-only          only show output/stderr when commands fail
  --no-progress          don't show progress.  No effect unless --errors-only.
debugging:
  --no-pty               don't use pseudoterminals
END
###############################################################################

$ENV{GIT_PAGER} = "cat";
my $recurse = My::Git::All->new();
$recurse->{maxdepth}     = $maxdepth     if defined $maxdepth;
$recurse->{no_git}       = $no_git       if defined $no_git;
$recurse->{basename}     = $basename     if defined $basename;
$recurse->{inline}       = $inline       if defined $inline;
$recurse->{no_brackets}  = $no_brackets  if defined $no_brackets;
$recurse->{indent}       = $indent       if defined $indent;
$recurse->{no_pty}       = $no_pty       if defined $no_pty;
$recurse->{format}       = $format       if defined $format;
$recurse->{format_width} = $format_width if defined $format_width;
$recurse->{separator}    = $separator    if defined $separator;
$recurse->{verbose}      = $verbose      if defined $verbose;
$recurse->{dry_run}      = $dry_run      if defined $dry_run;
$recurse->{errors_only}  = $errors_only  if defined $errors_only;
$recurse->{no_progress}  = $no_progress  if defined $no_progress;
$recurse->run(@ARGV);
