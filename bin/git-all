#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;

# This is a Git porcelain script that either runs the specified
# command with the specified arguments in the current directory if
# it's in a working tree, or finds git repositories within the current
# directory and runs the command/arguments in each of those if it's
# not.

use File::Basename qw(basename);

our $progname = basename($0);

our $maxdepth;
our $no_git;
our $basename;
our $inline;
our $no_brackets;
our $indent;
our $no_pty;
our $format;
our $separator;
our $verbose;
our $dry_run;

use Getopt::Long;
Getopt::Long::Configure("bundling", "gnu_compat", "require_order");
Getopt::Long::GetOptions(
    "max-depth|maxdepth=i" => \$maxdepth,
    "no-git"               => \$no_git,
    "basename"             => \$basename,
    "inline"               => \$inline,
    "no-brackets"          => \$no_brackets,
    "indent"               => \$indent,
    "no-pty"               => \$no_pty,
    "format=s"             => \$format,
    "separator=s"          => \$separator,
    "v|verbose+"           => \$verbose,
    "n|dry-run"            => \$dry_run,
    "h|help" => sub {
        usage(); exit(0);
    }
) or die("Do not type '$0 --help' for help yet.\n");

###############################################################################
sub usage { print <<"END"; }
usage:
  ${progname} [<option> ...] <cmd> [<arg> ...] [--- <dir> ...]
options:
  --help                 display this message
  --max-depth=DEPTH      maximum nesting level to find subdirectories
  --no-git               run <cmd> [<arg> ...] instead of git <cmd> [<arg> ...]
  --basename             only show basenames, not full directory pathnames
  --inline               prepend directory names to command stdout/stderr
  --no-brackets          no brackets around directory names
  --indent               indent command stdout/stderr
  --format=FORMAT        e.g., --format='project %s:'
  --separator=SEPARATOR  between directory name and command stdout/stderr
                         can specify escapes, e.g., --separator='\\t'
  --verbose
  --dry-run
debugging:
  --no-pty               don't use pseudoterminals
END
###############################################################################

$ENV{GIT_PAGER} = "cat";
my $recurse = My::Git::Porcelain::All->new();
$recurse->{maxdepth}    = $maxdepth    if defined $maxdepth;
$recurse->{no_git}      = $no_git      if defined $no_git;
$recurse->{basename}    = $basename    if defined $basename;
$recurse->{inline}      = $inline      if defined $inline;
$recurse->{no_brackets} = $no_brackets if defined $no_brackets;
$recurse->{indent}      = $indent      if defined $indent;
$recurse->{no_pty}      = $no_pty      if defined $no_pty;
$recurse->{format}      = $format      if defined $format;
$recurse->{separator}   = $separator   if defined $separator;
$recurse->{verbose}     = $verbose     if defined $verbose;
$recurse->{dry_run}     = $dry_run     if defined $dry_run;
$recurse->run(@ARGV);

package My::Git::Porcelain::All {

    use String::Unescape;

    sub new {
        my ($class) = @_;
        my $self = bless({}, $class);
        return $self;
    }

    sub run {
        my ($self, @arguments) = @_;

        my ($command, $arguments, $directories) = $self->split_arguments(arguments => \@arguments);
        my @directories = @$directories;
        @arguments = @$arguments;

        if (!defined $command) {
            warn("usage: git all GITCOMMAND [ARGUMENTS] [--- DIRECTORIES]\n");
            warn("       git all list-git-directories [--- DIRECTORIES]\n");
            exit(1);
        }
        if ($command eq "test-git-all-porcelain") {
            printf("\$command:     %s\n", $command);
            printf("\@arguments:   %s (%s)\n", scalar @arguments, join " ", @arguments);
            printf("\@directories: %s (%s)\n", scalar @directories, join " ", @directories);
            exit(0);
        }
        if (scalar @directories) {
            foreach my $directory (@directories) {
                if (-d $directory) {
                    if ($self->is_in_git_repos(directory => $directory)) {
                        $self->run_git_command_in(directory => $directory,
                                                  relative_directory => $directory,
                                                  command => $command,
                                                  arguments => \@arguments);
                    } else {
                        $self->recurse_here(directory => $directory,
                                            command => $command,
                                            arguments => \@arguments);
                    }
                } else {
                    warn("$directory: not a directory\n");
                }
            }
        } else {
            if ($self->is_in_git_repos()) {
                $self->run_git_command_in(directory => ".",
                                          command => $command,
                                          arguments => \@arguments);
            } else {
                $self->recurse_here(command => $command,
                                    arguments => \@arguments);
            }
        }
    }

    sub split_arguments {
        my ($self, %args) = @_;
        my @arguments = @{$args{arguments}};

        my $three_dashes_index = undef;
      argument:
        for (my $i = 0; $i < @arguments; $i += 1) {
            if ($arguments[$i] eq "---") {
                $three_dashes_index = $i;
                last argument;
            }
        }

        my @directories;
        if (defined $three_dashes_index) {
            @directories = splice(@arguments, $three_dashes_index + 1);
            splice(@arguments, $three_dashes_index);
        }

        my $command = shift(@arguments);

        if (wantarray) {
            return ($command, \@arguments, \@directories);
        } else {
            return {
                command => $command,
                arguments => \@arguments,
                directories => \@directories
            };
        }
    }

    sub is_in_git_repos {
        my ($self, %args) = @_;
        my $dir = $args{directory};

        my $pid = fork();
        if (!defined $pid) {    # cannot fork
            die("fork: $!");
        } elsif (!$pid) {       # child
            close(\*STDOUT);
            close(\*STDERR);
            if (defined $dir && $dir ne ".") {
                if (!chdir($dir)) {
                    die("chdir $dir: $!");
                }
            }
            if (!exec("git", "rev-parse", "--git-dir")) {
                die("exec git: $!");
            }
        } else {                # parent
            if (wait() == -1) {
                warn("unexpected: no child process\n");
                return 0;       # failure
            } else {
                if ($?) {
                    return 0;   # failure
                } else {
                    return 1;   # success
                }
            }
        }
    }

    use File::Find;
    use feature "say";
    use Cwd;
    use File::Spec;
    use File::Basename qw(dirname basename);
    use String::ShellQuote;

    sub has_io_pty {
        my ($self) = @_;
        return 0 if $self->{no_pty};
        return $self->{has_io_pty} if defined $self->{has_io_pty};
        eval {
            require IO::Pty;
            import IO::Pty qw();
        };
        return $self->{has_io_pty} = $@ ? 0 : 1;
    }

    sub recurse_here {
        my ($self, %args) = @_;
        my $depth = $args{depth} // 0;
        my $dir = $args{directory} // ".";
        my $command = $args{command};
        my @arguments = @{$args{arguments}};

        if (defined $self->{maxdepth}) {
            if ($depth > $self->{maxdepth}) {
                return;
            }
        }

        my $wanted = sub {
            if (-d $_) {
                if (-d "$_/.git") {
                    my @splitdir = File::Spec->splitdir($File::Find::name);
                    my $splitdir = scalar @splitdir;
                    my $newdepth = $depth + $splitdir - 1;
                    if (defined $self->{maxdepth}) {
                        if ($newdepth > $self->{maxdepth}) {
                            $File::Find::prune = 1;
                            return;
                        }
                    }
                    $self->run_git_command_in(depth => $newdepth,
                                              directory => $File::Find::name,
                                              relative_directory => $_,
                                              command => $command,
                                              arguments => \@arguments);
                    $File::Find::prune = 1;
                }
            }
        };
        find({ wanted => $wanted }, $dir);
    }

    sub run_git_command_in {
        my ($self, %args) = @_;
        my $depth = $args{depth} // 1;
        my $dir = $args{directory} // ".";
        $dir =~ s{^\.\/(?=.)}{};
        my $reldir = $args{relative_directory};
        my $command = $args{command};
        my @arguments = @{$args{arguments}};
        if ($command eq "list-git-directories") {
            print("$dir\n");
            return;
        }

        my $format = $self->{format};
        if (!defined $format) {
            $format = $self->{no_brackets} ? "%s" : "[%s]";
            if ($self->{inline}) {
                $format .= $self->{no_brackets} ? ":" : " ";
            }
        }
        my $print = $self->{basename} ? basename($dir) : $dir;
        if (!$self->{inline}) {
            printf($format . "\n", $print);
        }
        my $inline_prefix = $self->{inline} && sprintf($format, $print);
        my $inline_separator = defined $self->{separator} ? String::Unescape->unescape($self->{separator}) : undef;
        my $use_pipes_and_such = $self->{indent} || $self->{inline};

        my ($stdout_read, $stdout_write);
        my ($stderr_read, $stderr_write);
        if ($use_pipes_and_such) {
            if ($self->has_io_pty) {
                $stdout_read = IO::Pty->new(); # master
                $stderr_read = IO::Pty->new(); # master
                $stdout_write = $stdout_read->slave();
                $stderr_write = $stderr_read->slave();
            } else {
                pipe($stdout_read, $stdout_write) or die("pipe: $!");
                pipe($stderr_read, $stderr_write) or die("pipe: $!");
            }
        }

        my @cmd = ($command, @arguments);
        if (!$self->{no_git}) {
            unshift(@cmd, "git");
        }

        if ($self->{verbose} || $self->{dry_run}) {
            warn(sprintf("+ %s\n", shell_quote(@cmd)));
        }

        if ($self->{dry_run}) {
            return;
        }

        my $pid = fork();
        if (!defined $pid) {    # cannot fork
            die("fork: $!");
            # this point is never reached.
        } elsif (!$pid) {       # child
            if (defined $reldir && $reldir ne ".") {
                if (!chdir($reldir)) {
                    die("chdir $reldir: $!");
                }
            }
            if ($use_pipes_and_such) {
                open(STDOUT, ">&", $stdout_write) or die("open: $!");
                open(STDERR, ">&", $stderr_write) or die("open: $!");
            }
            if (!exec(@cmd)) {
                die("exec $cmd[0]: $!");
            }
        } else {                # parent
            my ($pid1, $pid2);

            my $do_a_wait = sub {
                my $wait = wait();
                my $status = $?;
                if ($wait == -1) {
                    warn("unexpected: no child process\n");
                } elsif (defined $wait) {
                    if (defined $pid1 && $wait == $pid1) {
                        if ($status) {
                            $self->warn_child_error($status, "stdout pipe");
                        }
                    } elsif (defined $pid2 && $wait == $pid2) {
                        if ($status) {
                            $self->warn_child_error($status, "stderr pipe");
                        }
                    } elsif (defined $pid && $wait == $pid) {
                        if ($status) {
                            $self->warn_child_error($status, "$cmd[0]");
                        }
                    } else {
                        warn("unexpected return value from wait()\n");
                    }
                } else {
                    warn("unexpected: wait() returned undefined\n");
                }
            };

            if ($use_pipes_and_such) {
                close($stdout_write) or die("close: $!");
                close($stderr_write) or die("close: $!");

                $pid1 = fork();
                if (!defined $pid1) {
                    die("fork: $!");
                } elsif (!$pid1) { # child
                    close($stderr_read) or die("close: $!");
                    select STDOUT; $| = 1;
                    local $_;
                    while (<$stdout_read>) {
                        s{\R\z}{};
                        if ($self->{inline}) {
                            print STDOUT $inline_prefix;
                            print STDOUT $inline_separator if defined $inline_separator;
                        } elsif ($self->{indent}) {
                            print STDOUT "    ";
                        }
                        print STDOUT "$_\n";
                        STDOUT->flush();
                    }
                    close($stdout_read) or die("close: $!");
                    exit;
                }

                $pid2 = fork();
                if (!defined $pid2) {
                    die("fork: $!");
                } elsif (!$pid2) { # child
                    close($stdout_read) or die("close: $!");
                    select STDERR; $| = 1;
                    local $_;
                    while (<$stderr_read>) {
                        s{\R\z}{};
                        if ($self->{inline}) {
                            print STDERR $inline_prefix;
                            print STDERR $inline_separator if defined $inline_separator;
                        } elsif ($self->{indent}) {
                            print STDERR "    ";
                        }
                        print STDERR "$_\n";
                        STDERR->flush();
                    }
                    close($stderr_read) or die("close: $!");
                    exit;
                }

                close($stdout_read) or die("close: $!");
                close($stderr_read) or die("close: $!");

                $do_a_wait->();
                $do_a_wait->();
            }

            $do_a_wait->();
        }
    }

    sub child_error_info {
        my ($self, $status) = @_;
        $status //= $?;

        my $exit     = $status >> 8;
        my $signal   = $status & 127;
        my $coredump = ($status & 128) ? 1 : 0;
        if (wantarray) {
            return ($exit, $signal, $coredump);
        } else {
            return {
                exit     => $exit,
                signal   => $signal,
                coredump => $coredump
            };
        }
    }

    sub warn_child_error {
        my ($self, $status, @child) = @_;
        $status //= $?;

        my ($exit, $signal, $coredump) = $self->child_error_info($status);
        if ($exit || $signal || $coredump) {
            my @message;
            push(@message, "returned $exit")      if $exit;
            push(@message, "with signal $signal") if $signal;
            push(@message, "core dumped")         if $coredump;
            my $message = join(", ", @message);
            if (!scalar @child) {
                @child = ("child");
            }
            warn("@child died: $message\n");
        }
    }

};                              # end package My::Git::Porcelain::All
