#!/usr/bin/env perl
use warnings;
use strict;
use List::Util qw(max);
use Getopt::Long;
use File::Basename qw(basename);
our $PROGNAME = basename($0);

our $quiet = 0;

Getopt::Long::Configure(qw(gnu_getopt no_ignore_case));
Getopt::Long::GetOptions(
    'h|help' => sub { usage(); exit(0); },
    'q|quiet+' => \$quiet,
) or die("Type '${PROGNAME} --help' for help.\n");
sub usage { print(<<"END"); }
usage: ${PROGNAME} [--quiet [--quiet]] <remote|-> <remote|->
--quiet silences branches neither ahead nor behind
--quiet twice silences branches not in one of the remotes
END

my $branches = getBranches();
my $all_branch_names = $branches->{all_branch_names};
my $all_remote_names = $branches->{all_remote_names};
my $branch_has_remote = $branches->{branch_has_remote};
my $remote_has_branch = $branches->{remote_has_branch};
my $branch_remotes = $branches->{branch_has_remotes};
my $remote_branches = $branches->{remote_has_branches};

if (scalar @ARGV < 2) {
    warn("git-ahead-behind <remote|-> <remote|->\n");
    exit(1);
}

my ($location_a, $location_b) = @ARGV;            # we only specify two remotes
$location_a = '(local)' if $location_a eq '-';
$location_b = '(local)' if $location_a eq '-';

my $fmt = "%-46s  %-6s  %-6s\n";
my $err_fmt = "%-46s  %s\n";

foreach my $branch (@$all_branch_names) {
    my $go = 1;
    my $in_a = $branch_has_remote->{$branch}{$location_a};
    my $in_b = $branch_has_remote->{$branch}{$location_b};
    if (!$in_a && !$in_b) {
        $go = 0;
        printf($err_fmt, $branch, 'is in neither location');
        next;
    }
    if (!$in_a) {
        $go = 0;
        if ($quiet < 2) {
            printf($err_fmt, $branch, sprintf('not in %s', $location_a));
        }
    }
    if (!$in_b) {
        $go = 0;
        if ($quiet < 2) {
            printf($err_fmt, $branch, sprintf('not in %s', $location_b));
        }
    }
    next if !$go;
    my $ph;
    my $rev_a = $location_a eq '(local)' ? "$branch" : "$location_a/$branch";
    my $rev_b = $location_b eq '(local)' ? "$branch" : "$location_b/$branch";
    my @cmd = ('git', 'rev-list', '--left-right', "${rev_a}...${rev_b}", "--count");
    open($ph, '-|', @cmd) or do {
        warn("git rev-list: $!\n");
        next;
    };
    while (<$ph>) {
        s{\R\z}{};
        my ($a, $b) = split();
        if ($quiet) {
            if (!$a && !$b) {
                next;
            }
        }
        printf($fmt, $branch, $a, $b);
    }
}

sub getBranches {
    my $ph;
    open($ph, '-|', 'git', 'branch', '-a') or do {
        warn("git branch: $!\n");
        return;
    };
    my @refs;
    while (<$ph>) {
        s{\R\z}{};
        $_ = substr($_, 2);
        next if m{/HEAD -> };
        push(@refs, $_);
    }
    my @branches;
    my @remotes;
    my %branch_has_remote;
    my %remote_has_branch;
    my %branch_remotes;
    my %remote_branches;
    foreach my $ref (@refs) {
        my $branch;
        my $remote;
        if ($ref =~ m{^remotes/(?<remote>[^/]+)/(?<branch>.*)$}) {
            $branch = $+{branch};
            $remote = $+{remote};
        } else {
            $branch = $ref;
            $remote = '(local)'; # indicates "local"
        }
        push(@branches, $branch);
        push(@remotes, $remote);
        $branch_has_remote{$branch}{$remote} = 1;
        $remote_has_branch{$remote}{$branch} = 1;
        push(@{$branch_remotes{$branch}}, $remote);
        push(@{$remote_branches{$remote}}, $branches);
    }
    @branches = distinct(@branches);
    @remotes  = distinct(@remotes);
    return {
        all_branch_names => \@branches,
        all_remote_names => \@remotes,
        branch_has_remote => \%branch_has_remote,
        remote_has_branch => \%remote_has_branch,
        branch_remotes => \%branch_remotes,
        remote_branches => \%remote_branches,
    };
}

sub distinct {
    my @result;
    my %occur;
    foreach my $str (@_) {
        push(@result, $str) if !$occur{$str}++;
    }
    return @result;
}
