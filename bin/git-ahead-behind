#!/usr/bin/env bash
set -o errexit
set -o pipefail
set -o nounset
# set -o xtrace
shopt -s lastpipe

declare -a locals=()            # locals=(master development)
declare -a remotes=()           # remotes=(remotes/origin/master remotes/origin/development)
declare -A has_local=()         # has_local[master]=1
declare -A has_remote=()        # has_remote[master]=1

fmt='%6s  %-32s  %-12s  %s\n'

git --no-pager branch --all --list --no-color --no-column | cut -c3- | grep -v -e '/HEAD -> ' | mapfile -t refs
for ref in "${refs[@]}" ; do
    if [[ "${ref}" = remotes/*/* ]] ; then
        has_remote["${ref#remotes/*/}"]=1
        remotes+=("${ref}")
    else
        has_local["${ref}"]=1
        locals+=("${ref}")
    fi
done
for remote in "${remotes[@]}" ; do
    local="${remote#remotes/*/}"
    if (( ! has_local["${local}"] )) ; then
        # printf "%6s  NOT CHECKED OUT: %s\\n" "-" "${remote}"
        continue
    fi
    git rev-list --left-right --count "${local}"..."${remote}" | read ahead behind
    if (( ahead )) ; then
        printf "%6d  AHEAD: %s %s\\n" "${ahead}" "${local}" "${remote}"
    elif (( behind )) ; then
        printf "%6d  BEHIND: %s %s\\n" "${behind}" "${local}" "${remote}"
    # elif (( verbose )) ; then
    #     :
    #     # printf "%6d  %s IN SYNC %s\\n" 0 "${local}" "${remote}"
    fi
done
for local in "${locals[@]}" ; do
    if (( ! has_remote["${local}"] )) ; then
        printf "%6s  NO REMOTES: %s\\n" "-" "${local}"
    fi
done

# if (( ! $# )) ; then
#     git status --short --branch
# else
#     git status --short --branch "$@"
# fi
