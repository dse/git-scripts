#!/usr/bin/env perl
use warnings;
use strict;
use open qw(locale);

use File::Find qw(find);
use Cwd qw(getcwd);
use IO::Handle;
use Fcntl;

our $CLR_EOL = "\e[K";
our $GREEN = "\e[0;32m";
our $RESET = "\e[m";
our $BYTES = 16384;

our $verbose = 0;
our $noGit;
our $list;
our $inline;
our $noHeader;
our $noPager;
our $minDepth;
our $maxDepth;
our $pipe;
our $progress;

use Getopt::Long;
Getopt::Long::Configure('bundling', 'gnu_compat', 'no_ignore_case', 'no_permute');
Getopt::Long::GetOptions(
    'G|no-git' => \$noGit,
    'l|list'   => \$list,
    'v|verbose+' => \$verbose,
    'i|inline'   => \$inline,
    'p|progress' => \$progress,
    'no-header'  => \$noHeader,
    'no-pager'   => \$noPager,
) or die();

my @gitCommand = ();

while (scalar @ARGV) {
    my $arg = shift(@ARGV);
    last if ($arg eq '---');
    push(@gitCommand, $arg);
}
if (!scalar @gitCommand) {
    $list = 1;
}

my @findArguments = @ARGV;
if (!scalar @findArguments) {
    @findArguments = ('.');
}

if (!-t 1) {
    $GREEN = '';
    $RESET = '';
}

gitFind();

sub gitFind {
    find(\&wanted, @findArguments);
}

sub wanted {
    my @lstat = lstat($_);
    return if !scalar(@lstat);
    return unless -d _;
    return $File::Find::prune = 1 if $_ eq 'node_modules';
    # print STDERR ("$File::Find::name\e[K\r");
    if (-d "$_/.git") {
        if ($list) {
            print($File::Find::name, "\n");
        } else {
            doTheFancyThing($_, $File::Find::name);
        }
        return $File::Find::prune = 1;
    }
}

sub doTheThing {
    my ($dir, $name) = @_;
    my $kid = doTheFancyThing($dir, $name);
    if ($kid == -1) {
        # child may have been reaped
        return;
    }
    my $exit = $? >> 8;
    my $sig  = $? & 127;
    my $dump = $? & 128;
    # make of that what you will
}

sub doTheNormalThing {
    my ($dir, $name) = @_;
    printf("%s==> %s <==%s\n", $GREEN, $name, $RESET);
    my $pid = fork();
    die("$!") if !defined $pid;
    if (!$pid) {                # child
        chdir($dir) or die("chdir: $!");
        my @cmd = (
            ($noGit ? () : ('git', '--no-pager')),
            @gitCommand,
        );
        exec(@cmd) or die("exec failed: $!");
    }
    return waitpid($pid, 0);
}

sub doTheFancyThing {
    my ($dir, $name) = @_;

    my $header = sprintf("%s==> %s <==%s\n", $GREEN, $name, $RESET);

    my ($stdoutRead, $stdoutWrite, $stderrRead, $stderrWrite);
    pipe($stdoutRead, $stdoutWrite) or die("pipe: $!");
    pipe($stderrRead, $stderrWrite) or die("pipe: $!");

    my @cmd = (
        ($noGit ? () : ('git', '--no-pager')),
        @gitCommand,
    );
    warn("@cmd\n");

    my $pid = fork() // die("fork: $!");
    if (!$pid) {
        # child
        chdir($dir) or die("chdir: $!");
        open(STDOUT, '>&', $stdoutWrite) or die("reopen: $!");
        open(STDERR, '>&', $stderrWrite) or die("reopen: $!");
        exec(@cmd) or die("exec failed: $!");
    }
    close($stderrWrite) or die("close: $!");
    close($stdoutWrite) or die("close: $!");

    # for select
    my $rbits = '';
    vec($rbits, fileno($stdoutRead), 1) = 1;
    vec($rbits, fileno($stderrRead), 1) = 1;

    # nonblocking I/O
    my $flags = fcntl($stdoutRead, F_GETFL, 0) or die("fcntl: $!");
    fcntl($stdoutRead, F_SETFL, $flags | O_NONBLOCK) or die("fcntl: $!");
    $flags = fcntl($stderrRead, F_GETFL, 0) or die("fcntl: $!");
    fcntl($stderrRead, F_SETFL, $flags | O_NONBLOCK) or die("fcntl: $!");

    STDOUT->autoflush(1);
    STDERR->autoflush(1);
    binmode(STDOUT);
    binmode(STDERR);
    binmode($stdoutRead);
    binmode($stderrRead);

    if ($progress) {
        print STDOUT ("\r", $CLR_EOL, $GREEN, "==> $name <==", $RESET);
    }

    while (1) {
        my $rout = $rbits;
        #                   rbits  wbits  ebits  timeout
        my $nfound = select($rout, undef, undef, undef);
        die("select: $!") if $nfound == -1;
        # last if $nfound == 0;
        my $hasStdout = vec($rout, fileno($stdoutRead), 1);
        my $hasStderr = vec($rout, fileno($stderrRead), 1);
        if (!$hasStdout && !$hasStderr) {
            last;
        }
        if ($hasStdout) {
            while (1) {
                my $data;
                my $bytes = sysread($stdoutRead, $data, 16384);
                if (!defined $bytes) {
                    last if $!{EAGAIN};
                    die("sysread: $!");
                }
                last if $bytes == 0;
                if (defined $header) {
                    print ("\r", $CLR_EOL) if $progress;
                    print STDOUT $header;
                    $header = undef;
                }
                print STDOUT $data;
            }
        }
        if ($hasStderr) {
            while (1) {
                my $data;
                my $bytes = sysread($stderrRead, $data, 16384);
                if (!defined $bytes) {
                    last if $!{EAGAIN};
                    die("sysread: $!");
                }
                last if $bytes == 0;
                if (defined $header) {
                    print ("\r", $CLR_EOL) if $progress;
                    print STDOUT $header;
                    $header = undef;
                }
                print STDERR $data;
            }
        }
        last if eof($stdoutRead) && eof($stderrRead);
    }
    close($stdoutRead);
    close($stderrRead);
    return waitpid($pid, 0);
}

# C:
#     int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
#     - only monitors fd numbers less than FD_SETSIZE
#     - poll(2) and epoll(7) do not have this limitation
#     - exceptfds monitors for exceptional conditions; see poll(2) ยง POLLPRI
#     - if timeout is NULL, select blocks indefinitely
#     - if timeout is zero, select returns immediately (for polling)
#     - on select, select() returns the # of fds contained in the three returned fd sets
# Perl:
#     select RBITS,WBITS,EBITS,TIMEOUT
