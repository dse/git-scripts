#!/usr/bin/env bash
set -o errexit
set -o pipefail
set -o nounset
# shopt -s lastpipe

# uses git-in-dir

# git find [<option> ...] <git-command> <git-command-arguments> [--- <directories|repositories>]

MAIN () {
    export GIT_PAGER=cat
    local action=find
    local green=$'\e'"[0;32m"
    local reset=$'\e'"[0m"
    local -i verbose=0
    local -i inline=0
    local mindepth=''
    local maxdepth=''
    local nopager=''
    local pipe=''
    local -i noheader=0
    local nogit=''

    # if executed as anything other than 'git find' or 'git-find'...
    if [[ "$(basename "$0")" != "git-find" ]] ; then
        nogit=--no-git
    fi

    while (( $# )) && [[ "$1" == "-"* ]] ; do
        case "$1" in
            -G|--no-git)
                nogit=--no-git
                ;;
            ---)
                break
                ;;
            -l|--list)
                action=list
                ;;
            -v|-verbose)
                verbose+=1
                ;;
            -i|--inline)
                inline=1
                ;;
            -y|--yellow)
                green=$'\e'"[0;1;33m"
                ;;
            --no-header)
                noheader=1
                ;;
            --no-pager)
                nopager='--no-pager'
                ;;
            -mindepth|--mindepth)
                shift
                if (( $# < 1 )) ; then >&2 echo "-mindepth requires an argument"; exit 1; fi
                mindepth="$1"
                ;;
            -maxdepth|--maxdepth)
                shift
                if (( $# < 1 )) ; then >&2 echo "-maxdepth requires an argument"; exit 1; fi
                maxdepth="$1"
                ;;
            -P|--pipe)
                shift
                if (( $# < 1 )) ; then >&2 echo "-P/--pipe requires an argument"; exit 1; fi
                pipe="$1"
                ;;
            -P*)
                pipe="${1#-p}"
                ;;
            --pipe=*)
                pipe="${1#--pipe=}"
                ;;
            *)
                >&2 echo "unknown option: $1"
                exit 1
                ;;
        esac
        shift
    done

    local -a gitcommand=()
    local -a findarguments=()
    local arg=''

    while (( $# )) ; do
        arg="$1"
        shift
        if [[ "${arg}" = "---" ]] ; then
            break
        fi
        gitcommand+=("${arg}")
    done

    while (( $# )) ; do
        arg="$1"
        shift
        findarguments+=("${arg}")
    done

    if [[ ! -t 1 ]] ; then
        green=''
        reset=''
    fi

    if (( ! ${#gitcommand[@]} )) ; then
        TAKE-ACTION GIT-FIND-LIST
    else
        case "${action}" in
            list)
                TAKE-ACTION GIT-FIND-LIST
                ;;
            find)
                TAKE-ACTION GIT-FIND
                ;;
        esac
    fi
}

TAKE-ACTION () {
    local action="$1"; shift
    local i
    if (( ${#findarguments[@]} )) ; then
        for i in "${findarguments[@]}" ; do
            "${action}" "${i}"
        done
    else
        "${action}" .
    fi
}

GIT-FIND-LIST () {
    if (( verbose )) ; then
        find "$1" \
             ${mindepth:+-mindepth "${mindepth}"} \
             ${maxdepth:+-maxdepth "${maxdepth}"} \
             -type d \
             \! \( -name node_modules -prune \) \
             \! \( -exec test -d '{}/.git' \; -print -prune \) -exec echo '# {}' \;
    else
        find "$1" \
             ${mindepth:+-mindepth "${mindepth}"} \
             ${maxdepth:+-maxdepth "${maxdepth}"} \
             -type d \
             \! \( -name node_modules -prune \) \
             -exec test -d '{}/.git' \; -print -prune
    fi
}

GIT-FIND () {
    local -a find1
    local -a find2
    local -a find3
    local -a find

    if (( $# )) ; then
        if (( inline )) ; then
            find "$1" \
                 ${mindepth:+-mindepth "${mindepth}"} \
                 ${maxdepth:+-maxdepth "${maxdepth}"} \
                 -type d \
                 \! \( -name node_modules -prune \) \
                 -exec test -d '{}/.git' \; \
                 -prune \
                 -exec git in-dir $nogit $nopager ${pipe:+"--pipe=${pipe}"} -p'[{}] ' {} "${gitcommand[@]}" \;
        else
            # what to find
            find1=(
                find "$1"
                ${mindepth:+-mindepth "${mindepth}"}
                ${maxdepth:+-maxdepth "${maxdepth}"}
                -type d
                \! \( -name node_modules -prune \)
                -exec test -d '{}/.git' \;
            )

            # print header (may run with or without)
            find2=(
                -exec echo "${green}==> {} <==${reset}" \;
            )

            # what action to take
            find3=(
                -prune
                -exec git in-dir $nogit ${pipe:+"--pipe=${pipe}"} {} "${gitcommand[@]}" \;
            )

            if (( noheader )) ; then
                find=("${find1[@]}"
                      "${find3[@]}")
            else
                find=("${find1[@]}"
                      "${find2[@]}"
                      "${find3[@]}")
            fi
            "${find[@]}"
        fi
    fi
}

#------------------------------------------------------------------------------
MAIN "$@"
