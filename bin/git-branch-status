#!/usr/bin/env bash
set -o errexit
set -o pipefail
set -o nounset
shopt -s lastpipe

# based on https://stackoverflow.com/questions/7773939/show-git-ahead-and-behind-info-for-all-branches-including-remotes
# was in: https://gist.github.com/jehiah/1288596
# now in: https://github.com/bill-auger/git-branch-status/
# also:   https://github.com/jwiegley/git-scripts

PROGNAME="$(basename "$0")"

main () {
    local verbose=0
    local ahead=1
    local behind=1
    get-options "$@"
    shift $((OPTIND - 1))
    export GIT_BRANCH_AHEAD="${ahead}"
    export GIT_BRANCH_BEHIND="${behind}"
    check-branches
}

check-branches () {
    local T_RESET=''
    local T_AHEAD=''
    local T_BEHIND=''
    if [[ -t 1 ]] ; then
        T_RESET=$'\e''[0m'      # reset
        T_AHEAD=$'\e''[1;33m'   # bright yellow
        T_BEHIND=$'\e''[1;35m'  # bright magenta
    fi
    export T_RESET
    export T_AHEAD
    export T_BEHIND
    export BSVERBOSE="${verbose}"
    git for-each-ref --format='%(refname:short) %(upstream:short)' refs/heads | while read local remote ; do
        if [[ ! -v remote ]] || [[ "${remote}" = "" ]] ; then
            >&2 echo "${local}" has no upstream
        else
            check-branch "${local}" "${remote}"
        fi
    done
}

check-branch () {
    local local="$1"
    local remote="$2"
    shift 2
    if [[ -z "${remote}" ]] ; then
        return
    fi
    ( echo "${local}" && echo "${remote}" && git rev-list --left-right "${local}...${remote}" -- ) | format
}

format () {
    awk '
        BEGIN {
            ahead = 0;
            behind = 0;
            ORS = "";
            OFS = "";
            verbose = 0 + ENVIRON["BSVERBOSE"];
            T_AHEAD  = ENVIRON["T_AHEAD"];
            T_BEHIND = ENVIRON["T_BEHIND"];
            T_RESET  = ENVIRON["T_RESET"];
            AHEAD = 0 + ENVIRON["GIT_BRANCH_AHEAD"]
            BEHIND = 0 + ENVIRON["GIT_BRANCH_BEHIND"]
        }
        NR == 1 { local = $0; next; }
        NR == 2 { remote = $0; next; }
        /^</ { ahead += 1; }
        /^>/ { behind += 1; }
        END {
            if ((ahead && AHEAD) || (behind && BEHIND) || verbose) {
                printf("%s...%s", local, remote);
                if (AHEAD) {
                    if (ahead || verbose) {
                        print(" ", T_AHEAD);
                        printf("ahead %d", ahead);
                        print(T_RESET);
                    }
                }
                if (BEHIND) {
                    if (behind || verbose) {
                        print(" ", T_BEHIND);
                        printf("behind %d", behind);
                        print(T_RESET);
                    }
                }
                printf("\n");
            }
        }
    '
}

get-options () {
    while getopts 'hvab' OPTION ; do
        case "${OPTION}" in
            'a')
                ahead=1
                behind=0
                ;;
            'b')
                ahead=0
                behind=1
                ;;
            'h')
                usage
                exit 0
                ;;
            'v')
                verbose=$((verbose + 1))
                ;;
            '?')
                # short option invalid or missing argument
                >&2 echo "Type '${PROGNAME} -h' for more information."
                exit 1
                ;;
        esac
    done
}

usage () { cat <<EOF; }
usage:
    ${PROGNAME} [<option> ...] [--] [<filename> ...]
options:
    -v       verbosity
    -h       help
EOF

###############################################################################
main "$@"
